\chapter{Group Communication}
\minitoc

A) the lab description of the respective topic (to make the report selfcontained)\\
B) 1-2 pages pointing out how much they solved and which issues they encountered\\
C) A “print” of an example run\\
D) 1-2 pages where they relate what they did to the relevant theory in the curriculum\\
E) max 1 page conclusion, concluding what was solved well (perhaps even makes you proud :-)- and what could be done differently/better and why\\


In this chapter we shall describe the result of the JGroup exercise. In section \ref{jgroup_solution} we demonstrate our solution. In section \ref{jgroup_run} we show an example run of the solution. In section \ref{jgroup_motivation} we discuss the underlying theory and relate that to the solution. In section \ref{jgroup_conclusion} we round up the chapter.


\section{lab description}

\textit{The primary focus of this week’s assignment is to understand the basic concepts of group communication.} \\

\textit{Your primary task is to add group communication functionality to task manager application using JGroups toolkit. You can assume a scenario as shown in the following figure, where multiple instances of task manager applications are running and providing functionality for their clients to create, read, update and delete tasks, as described in the previous lab exercises.}\\

\textit{Each of instance of a task manager server is running with it’s own set of tasks (i.e. their own copy of task-manager-xml) and want to communicate their incremental state changes (i.e updates to their own tasks such as add, delete, update to a task) with the other instances of task manager application.  On top of that, the task manager application also needs to support state synchronization among the instances, to bring all the task manager instances to same state, i.e to have same tasks among all the instances. The task manager application  achieves this functionality by creating a Task Group using JGroups toolkit and all the instances of task manager connect to the Task Group by using JChannel. Also note that a task manager instance may choose join or leave the task group at any point of time.}\\

\textit{The Assignment}\\

\textit{You are required to add/implement the following functionality to the task manager JGroup application.}\\

\textit{Extend the task manager xml with a ‘required’ attribute on the task element, which accepts boolean values (true/false) indicating whether the task is required to be executed later or not.}\\

\textit{Implement the following operations on task manager JGroup application.}\\

\textit{\textbf{execute}: accepts id of a task and all instances of task managers in the group execute the task matching to id, by assigning the ’status’ attribute to ‘executed’ and ‘required’ attribute to ‘false’.}\\

\textit{\textbf{request}: accepts id of a task and  all instances of task managers in the group assigns the ‘required’ attribute to ‘true’ for the task matching to the id.}\\

\textit{\textbf{get}: accepts a name of a role as input and then all instances of task managers in the group will output their tasks matching to the role specified in their task manager xml.}\\




\section{Solution}
\label{jgroup_solution}

The solution consists of two main classes. A sender and a receiver. The sender's task is to take user requests and relay them to the receivers.
The receiver's task is to... receive the requests. \\ 

The sender instantiates a 'channel' object. This is similar to a socket and this is the main concept in the JGroup API. messages are sent 
over the channel to the group or to individual processes.  The Message object itself takes the sender's and receiver's addresses as well as the marshalled message. If the sender and receiver addresses are null the message is multicast to the group members\\

Our sender class first packages a user request in an envelope object (which can hold a request command as well as a Task object) and then serializes the envelope object before multicasting a JGroup Message object containing this serialized envelope to the group i.e., 
a request for a given operation on a given task is put into an envelope object with the task’s ID. The envelope is marshalled and then multicast to the group as a JGroup ‘Message’.\\

The receivers subscribe to the same JGroup channel as the sender has instantiated. The group receivers will unmarshall the message back into an envelope object giving access to the original request and the Task object. \\

The Message object in JGroups consists of a destination address, a sender address and a message, in this case the serialized envelope. JGroup delivers
multicast as well as one-to-one communication. By providing the Message object with a receiver address that message is sent to that receiver only and not to the group.

\section{Example Run}
\label{jgroup_run}
In our taskmanagerapplication we first create and connect to the group 'channel'. 
Then we fetch the state which in turn invokes the receivers 'setstate' method. 
This is to ensure a synchronized state across the group.   

\begin{lstlisting}[caption=group setup]
// channelTasks = ChannelHelper.getNewChannel(localIp, addPort);
channel = new JChannel();

// Receiver (taskprovider, channel) 
channel.setReceiver(new TaskReceiver(provider, channel));

// Instantiate a Group. If this is the first connect, the group will be created.
channel.connect("Add Tasks Channel");

// State transfer. getState(target instance, timeout). null means get the state from the coordinator/the first instance.        
channel.getState(null, 10000);

// the busines end.
eventLoop();

// when exiting the eventLoop we exit the group channel
channel.close();
\end{lstlisting}

After the initial creation and state transfer steps we enter the eventLoop. Here we receive requests, transform the request 
into a Message object and send messages to the group. A request is wrapped in an 'Envelope' object together with possibly a Task.
The WriteToChannel(envelope, channel) method then serializes the envelope and wraps it in a JGroup Message object, which contains 
sender and receiver addresses, and sends theat message to the group.\\

Note overloads of the channel.send() method exists which allows us to send the message to a single address instead of the group.

\pagebreak
\begin{lstlisting}[caption=eventloop]
// create an empty message container
Envelope envelope = new Envelope();

switch (command.toLowerCase().trim()) {
        case "request":
        System.out.println("type or paste task Xml you want to request (in single line)!");
        System.out.print("> ");
            		
        String requestXml = in.readLine();

        Task requestTask = TaskSerializer.DeserializeTask(requestXml);
        envelope.command = command;
        envelope.data.add(requestTask);

        // here we send the message to the group. (message, Channel)
        WriteEnvelopeToChannel(envelope, channel);
            		
   	   	break;

\end{lstlisting}

A receiver can either implement JGroup.receiver or extend receiverAdapter and simply override the 'receive(Message)' method. 
In our application we do the later. \\

After receiving a Message the application deserializes the message into an Envelope object.
The envelope contains the request and possibly a Task object on which to perform the requested action.


\begin{lstlisting}[caption=receiver]
if(DeserializeEnvelope.command.equals("request")){
	    Task taskWithId = GetTaskWithId(DeserializeEnvelope.data.get(0).id);
		
	    if (taskWithId != null) {
		    // execute therequired 'action' on the given Task object
	      	taskWithId.required = true;
		
	    try {
		  // persist changes
		  provider.PersistTaskManager();
	    } catch (JAXBException ex) {
	        System.out.println(prefix + "Failed to persist envelope Xml. Error message" + ex);
	    } catch (IOException ex) {
	        System.out.println(prefix + "Failed to persist envelope Xml. Error message" + ex);
	    }
		
	    System.out.println(prefix + "Task with Id:" + DeserializeEnvelope.data.get(0).id + " requested!" + "total number of tasks: "
	            + provider.TaskManagerInstance.tasks.size());
		
	} else {
	    System.out.println(prefix + "Task with Id:" + DeserializeEnvelope.data.get(0).id + " can not be found and hence NOT requested!" + " Total number of tasks: " + provider.TaskManagerInstance.tasks.size());
	}
}
\end{lstlisting}





\section{Theoretical Motivation}
\label{jgroup_motivation}
Remote invocation paradigms (RPC, RMI) imply a coupling between the participants that is often not desirable in distributed systems. The sender need to know the receiver at the time of communication. A common means of decoupling the system is by using a form of indirect communication. Indirect communication is defined as 'entities communicating through an intermediary'. Note there an be potentially many receivers of a single subject/object. \\

Uncoupling the communicating entities reveal two properties: 

\begin{enumerate}
\item Space uncoupling: the sender does not know the receivers' identity and vice versa. 
\item Time uncoupling: the sender and receiver(s) does not need to exist at the same time.  
\end{enumerate}

This is why indirect communication is desirable in environments where change is anticipated. Note in reality systems are not always both space and time uncoupled. \\


Various techniques for indirect communication exist:\\

\begin{enumerate}
\item Group communication: A message is sent to an address  and then this message is delivered to all members of the group. The message delivery is guaranteed a certain ordering.Sender is not aware of the identity of the receivers. Note this does make the system vulnerable to single-point-failures if ...? \\

\item Publish-subscribe systems: publishers publish structured events to an event service and subscribers express interest in particular events through  subscriptions. \\

\item Message-queue systems:A process (many processes) sends a message to a (usually FIFO) queue. A single receiver then removes them one by one.\\

\item Shared memory systems: Processes access DSM by reads and updates to what appears to be ordinary memory within their address space. However, an underlying runtime system ensures that processes executing at different computers observe the updates made by one another.\\
\end{enumerate}

\subsection{Group Communication Programing Model}

A group has a conceptual group-membership. Processes may join or leave the group. The essential feature of group communication is that it issues only a single multicast operation to send a message to each member of the group (a group of processes). \\

This is, off course, more effective than sending a message once to each member of the group. \\

The most basic form of group communication, IP Multicast, provides some guarantees as to the delivery of messages, namely:

( Reliability: (see Ch 2) )

\begin{enumerate}
\item Integrity. The message received is the same as the one sent, and no messages are delivered twice. 
\item Validity. Any outgoing  message is eventually delivered.
\item Agreement. If the message is delivered to one process, then it is delivered to all processes in the group.
\end{enumerate}

But IP multicast offers no guarantees as to reliability i.e., no ordering of messages and packages may be lost. \\

JGroups is build as an IP multicast application using a transport protocol ( UDP TCP, or JMS (Java Message Service)) 
and, crucially,  it delivers reliability and group membership. Among other things this includes:\\
\begin{enumerate}
\item lossless transmission of a message to all recipients (with retransmission of missing messages.)
\item fragmentation of large messages into smaller ones and reassembly at the receiver's side
\item ordering of messages, e.g. messages m1 and m2 sent by P will be received by all receivers in the same order, and not as m2, m1 (FIFO order)
\item atomicity: a message will be received by all receivers, or none of them.
\item Knowledge of who the members of a group are. 
\item Notification when a new member joins, an existing member leaves, or an existing member has crashed.
\end{enumerate}

JGroups consists of 3 main parts: (1) the Channel used by developers to build reliable group communication applications, (2) the building blocks which are layered on top of the channel and provide a higher abstraction level and (3) the protocol stack, which implements the properties specified for a given channel.\\

JGroups is highly configurable and developers can put together a protocol stack that suits their particular needs ranging from fast but unreliable to slower but reliable protocol stacks. i.e., a system might be composed, depending on the protocol stacks used, in such a way that it offers lossless transmission but not ordering of messages or lossless transmission, atomicity and ordering of messages.\\

In JGroups the ‘channel’ abstraction is the group membership itself. When connecting to a channel a process joins the group. A Message abstraction is the means be which a process sends a message to the group. the message consists of a receiver address, a sender address and a message. 


\section{Conclusion}
\label{jgroup_conclusion}
Group communication as provided by IP multicast suffers from omission failures, messages may be lost. It also offers no ordering of messages. These properties can be provided by application layers e.g. JGroups. JGroups is an overlay on the basic IP multicast offering amongst other things reliability and ordering in group communication. \\

JGroups delivers reliable multicast i.e., where IP multicast is unreliable, it might drop messages, deliver messages multiple times, or deliver messages out of order, JGroups offer a reliable multicast. It offers atomicity; all members receive the message or none does. It offers ordering; the messages will be received by all receivers in the same order. And it offers lossless transmission by retransmission of messages.\\

On a closing note, the flexibility offered by JGroups in composing a protocol stack was beyond the available time. Therefore we did only try out JGroups most basic stack setup, i.e., IP multicast over UDP. Given time it would have been nice to be able to try out some different configuration of the protocol stack.  

