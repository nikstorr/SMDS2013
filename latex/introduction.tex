\chapter{Introduction}
\section{Project Presentation}

This report is an examination of some of the principles seen in the application of distributed systems. The report's modus operandi is to test the underlying theory on small independant applications. Projects in the report are based on a ‘taskmanager’ application. The basic concept provides a means of creating, editing, deleting and persisting tasks. \\

The report consists of 8 chapters each eamining a single topic in distributed systems. The taskmanager application provides an empirical dimension and is the steepingstone for the analysis of individual topics. \\

Due to the pressure of other concurrent courses at ITU we have not been able to provide a single coherent project examining all issues, instead we use the individual projects from the course lab exercises as the empirical background for a discussion of the challenges of distributed systems. The projects therefore only serve as proof of concept and as a basis for analysis and discussion of concepts.  \\

In the fisrt chapters the taskmanager application is used to set up a client-server based application. Later chapters provide other functionality such as group communication and security, web services and serialization etc. \\

The idea is to try out some of the techniques commonly seen in the implementation of distributed systems and thereby demonstrate our understanding of the theories behind as well as (some of) the challenges faced by distributed systems. 

\section{Taskmanager}

The taskmanager application is founded on an xml document containing ‘tasks’. The xml document is serialized using JAXB into an object tree. Note in the google app engine project we use JPA for serializing in order to accommodate google app engine specific requirements for persistence. The taskmanager.xml file structure looks like this:

\begin{lstlisting}[caption = taskmanager.xml]
<cal>
 <tasks>
  <task id="handin-01" name="Submit assignment-01" date="16-12-2013"
	status="not-executed" required="false">
	<attendants>student-01, student-02</attendants>
	<role>student</role>	
  </task>
  - 
  - 
  - 
 </tasks>
</cal>
\end{lstlisting}

\subsection{Task}
The taskmanager application holds a list of Task objects. A task has the following properties:\\

ID (a unique identifier), name (the name of the task), date (the date of creation), status (status of the task. E.g executed or non-executed.),
required (E.g. ‘true’ or ‘false’.’), role (role, is an access control technique in where the role of a task signifies the access rights level of that task. ), Attendants (a list of attendants for the task)\\


\begin{lstlisting}[caption=Task]
@XmlRootElement(name = "task")
public class Task implements Serializable {
    @XmlID
    @XmlAttribute
    public String id;
    @XmlAttribute
    public String name;
    @XmlAttribute
    public String date;
    @XmlAttribute
    public String status;
    @XmlAttribute
    public String description;
    @XmlElement
    public String attendants;
    @XmlElement
    public String role;
    @XmlAttribute
    public Boolean required;
}

\end{lstlisting}

\subsection{report structure}

Chapter 2 is dedicated to the basics of setting up a distributed system; nodes run concurrently, there’s no notion of time and the potential crash of one node should not influence the rest. A server client structure is implemented and we discuss the intricacies of java Servlets and JDOM. \\	

In chapter 3 we'll take a look at 'Jersey' web services. A server client communication is established. \\

In chapter 4 we create a RESTfull service. The taskmanager is made available as resources. 
Clients access task via HTTP but in the way that the HTTP protocol was originally intended to be used. \\

In chapter 5 we discuss security in distributed systems. We implement a simple role-based security control mechanism and we encrypt the messages sent between nodes in the system.    \\
-
-
\section{Baseline model}

Before we continue, a summary of the challenges in distributed systems is outlined:


\subsection{Heterogeneity}
Each node in a distributed system may have been developed in different languages on different OS’.   

\subsection{Openness}

Nodes communicate through interfaces. A system is open if it publishes a public interface. It is paramount that the protocols are followed closely to mask the differences as seen above. 

\subsection{Security}

Confidentiality: (authorization)
Integrity (protection against corruption i.e, the message you receive is genuine.)
Availability: (?)


The solution is to use encrypted messages.

\subsection{Scalability}

Preferably, the cost of adding another node should be constant.This has an ipact on the algorithms used in distributed systems.

\subsection{Availability and Failure Handling}

Detect failures using checksums.
Mask failures by catching the failure and resending the message 
Tolerate failures:  e.g. by letting the browser timeout instead of waiting indefinitely tying down resources. 
Recover from failure: e.g. by performing a server rollback.
Redundancy: i.e., DNS servers keep copies at several locations in case one server crashes the tables are always available elsewhere. 

\subsection{Concurrency}
How to solve concurrent requests? 

\subsection{Transparency}

How to make the system seem one though it is in fact comprised of several subsystems perhaps located on different continents.

\begin{enumerate}
\item Access transparency: access to local and remote resources must go through the same  interfaces.
\item Location transparency: The node accessing a resource should not need to know it’s location.
\item Concurrency transparency: Multiple nodes can access the resource simultaneously. 
\item Replication transparency: multiple instances of a resources can be utilized without the nodes noticing.
\item Failure transparency:In case of failure in the resource (hardware or software) the node should be able to complete its task.
\item Mobility transparency: the resource can be moved without the node noticing
\item 
\item 
\end{enumerate}


\section{Failure model}

The above challenges are a t the root of a basic failure model for distributed systems. \\

There are three places of potential failure: the sender, the channel and the receiver. 
The basic failure model in distributed system distinguish between failure in the channel and failure in the processes.

\begin{enumerate}
\item Omission: Channel failure. An outgoing message never arrives at the destination
 
\item Send-Omission: Process failure. The message never leaves the process.
 
\item Receive Omission: Process Failure. The message arrives but theprocess can't find it.
 
\item Crash: Process failure. A process halts. Others might not recognize this
 
\item Fail-stop: Process failure. A process halts. Others see this.
 
\item Arbitrary: Process or channel failure. All or any of the above.

\end{enumerate}

