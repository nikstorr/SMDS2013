\chapter{TCP server and Serialization}
\minitoc


In this chapter we describe the result of the TCP lab exercise. in section \ref{tcp_lab} we describe the assignment. In section \ref{tcp_solution} we describe our solution. in section \ref{tcp_example} we provide an example run of the solution. In section \ref{tcp_reflection} we reflect on the theory behind the assignment. In section \ref{tcp_conclusion} we sum up what we've learned and round up the chapter.

\section{lab description}
\label{tcp_lab}
\textit{The purpose of this week’s lab exercise is to develop a simplified version of web server for task manager that runs on TCP protocol.}\\

\textit{In this lab exercise, you are required to develop the code for the following functionality.}\\

\textit{Develop java serialization classes for task-manager-xml using Java Architecture for XML Binding (JAXB) APIs (by annotating java classes) to handle deserialization/serialization from/to task-manager-xml in the server.}\\

\textit{Develop TaskManagerTCPServer and TaskManagerTCPClient classes to implement the above described functionality of server and client that communicate on the TCP protocol.}\\


\begin{comment}
[Optional] The server described above can only handle one single client at a time in each run. In order to make the server more robust and handle multiple clients concurrently, one may follow the approach suggested in the page. 173 of the course textbook [DS], to create a new connection for every client request that will run on a separate thread. Therefore, develop a TaskManagerTCPServer that can handle multiple concurrent clients.\\

[Optional] The functionality of TaskManagerTCPServer can be extended to offer more commands (e.g. OPTIONS, HEAD) similar to the HTTP protocol. In case of OPTIONS command, one may describe the list of commands offered by the server, where as for HEAD, one may only provide the number of tasks available for a given attendant instead of sending all the available tasks to the client.\\

\end{comment}


\section{Solution}
\label{tcp_solution}

In our solution we first deserialize the xml document into a 'taskmanager' object and ‘Task’ objects. Then we create appropriate input- and output streams for communicating with clients. \\

Serialization and deserialization to and from xml is done with the JAXB API. To quote Oracle; \textit{JAXB provides methods for unmarshalling (reading) XML instance documents into Java content trees, and then marshalling (writing) Java content trees back into XML instance documents.} \\

JAXB uses annotations to achieve this. We annotate the Task and Taskmanager  Java objects and JAXB then knows how to convert these annotated objects into an xml tree-structure and back into an object graph.\\

The TCP server in our solution first connects to a serversocket and then waits for incoming requests on the port bound to the socket. Note this is a blocking call. The Client creates a socket on the same port but this time with the servers InetAddress as a second argument. \\

The server and client communicates by passing messages in and out of the matching inputstreams and outputstreams. Command messages are passed via the writeUTF and received by the readUTF methods (as bytes). The Task and taskmanager objects are then sent via writeObject and received by readObject methods (objects must Serializable in order to be sent with writeObject). \\

\subsection{http protocol}

The server responds to the client’s request by sending the request back. The client then proceeds accordingly. This mimics the HTTP protocol request-response pattern in detail?.

\section{example run}
\label{tcp_example}

In this example run we start out with an xml document containing one Task. Before the example run the xml document looks like this:

\begin{lstlisting}[caption=xml before run]
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<taskmanager>
	<tasks>
		
		<task id="handin-01" name="Submit assignment-01" date="16-12-2013"
			status="not-executed">
			<description>
				Work on mandatory assignment.
			</description>
			<attendants>student-01, student-02</attendants>
		</task>	
	</tasks>
</taskmanager>

\end{lstlisting}

During the run the client requests the POST method with new Task. After the run the xml document looks like this:

\begin{lstlisting}[caption=xml after POST]
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<taskmanager>
	<tasks>
		<task id="handin-01" name="Submit assignment-01" date="16-12-2013" status="not-executed">
			<description>
				Work on mandatory assignment.
			</description>
			<attendants>student-01, student-02</attendants>
		</task>
		<task id="one more cup of coffe" name="Tout les circles" date="15-09-2013" 
		status="mais jai le plus grande maillot du monde">
			<description>recondre</description>
			<attendants>bjarne, lise, hans, jimmy</attendants>
		</task>
	</tasks>
</taskmanager>
\end{lstlisting}

The client then requests the PUT method wanting to change the new 'one more cup of coffe' Task description from 'recondre' to 'recondre les roix'. Finally, the client requests the DELETE method with the taskid 'handin'01' parameter. After the run the xml document now looks like this:

\begin{lstlisting}[caption=xml after PUT]
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<taskmanager>
	<tasks>
		<task id="one more cup of coffe" name="Tout les circles" date="15-09-2013" status="mais jai le plus grande maillot du monde">
			<description>recondre les roix</description>
			<attendants>bjarne, lise, hans, jimmy</attendants>
		</task>
	</tasks>
</taskmanager>
\end{lstlisting}

\pagebreak

The TCP server code of interest looks like this.
% \lstinputlisting{TCPserver.java}

\begin{lstlisting}[caption= servers initial request-response]
while(running){
         System.out.println("\nServer: Waiting for client command");
         // client request
         String message = dis.readUTF(); // blocking call
         System.out.println("Server: client command received : " + message);
         // accept client request by returning the (request) message
         dos.writeUTF(message);    

\end{lstlisting}

\begin{lstlisting}[caption= server POST method]
if(message.equals("POST")){
    // receive Task object from client
   	Task t = (Task) ois.readObject();
   	
   	System.out.println("Server: object received '" + t.name +"', persisting object...");
   	// Add Task object to takmanager collection
   	serializer.allTasks.tasks.add(t);
   	// persist to xml document<
   	serializer.Serialize();
   	// acknowledge to client   	
   	dos.writeUTF("Task with id: '" +t.id + "' saved");
}

\end{lstlisting}


The corresponding TCP client code looks like this.
%\lstinputlisting{TCPclient.java}


\begin{lstlisting}
InetAddress serverAddress = InetAddress.getByName("localhost");            
// Open a socket for communication.
Socket socket = new Socket(serverAddress, 7896);
// Request message to server
String  message = "POST";			
System.out.println("Client: requesting " + message);

dos.writeUTF(message);		// send the request
response = dis.readUTF();	// blocking call          
System.out.println("Client: server response : " + response);         

Task t = new Task();
t.name = "Tout les circles";
t.id = "one more cup of coffe";
t.date = "15-09-2013";	
t.description = "recondre";
t.status = "mais jai le plus grande maillot du monde";
t.attendants = "bjarne, lise, hans, jimmy";

// if server acknowledges
if(response.equals(message)){
   	System.out.println("Client: server accepted. Sending object");
   	// send the Task object
   	ous.writeObject(t);
}else{
   	System.out.println("Client: the server did not acknowledge the object. Aborting.");
}

response = dis.readUTF();
System.out.println("Client: server response : " + response)
\end{lstlisting}



\section{Reflection}
\label{tcp_reflection}

In this exercise we worked with protocols at the transport layer level, the TCP protocol to be precise. \\

The TCP protocol is part of a protocol suite. A protocol suite is a stack of protocols each responsible for a single logical task. 
Each layer communicates with the layer above and below, only. \\

At the bottom of the TCP/IP suite are the physical layer (hardware). On top of the physical layer the network layer provides an interface to the transport layer, application services (and their protocols) are built on top of the transport layer, based on TCP e.g. HTTP, SMTP, POP, FTP etc. 
More layers can be added to provide additional functionality e.g. security etc.\\

Using protocols gives us network independance i.e., different application types and languages can use the same network to communicate 
as long as they comply to the same protocol(s). \\

In our example application the transmission Control Protocol (or TCP protocol) communicated with the network layer through a ‘socket’ connection. Our client existed in the application/presentation layer utilizing the TCP transport protocol to communicate through the network layer with another node.  \\

Nodes communicated through a port. Both client and server addressed messages to the same port. The transport address (the IP number) was in this case composed of the computers  ‘localhost’ address and the port number. \\

There are two transport protocols in the TCP/IP suite; UDP and TCP. UDP transfers text messages (IP packets) and TCP transfers byte streams (as IP packets). Furthermore, TCP is reliable and ordered i.e., TCP provides guarantees as to the ordering of its messages and it provides guarantees as to the delivery of the messages. \\

In contrast, the underlying network protocol (the IP protocol ) offers only ‘best-effort’ semantics, there’s no guarantee of delivery and packets can be lost, duplicated, delayed or delivered out of order. This seem logical as the network layer (IP protocol) can not control the other end of the connection. 

\pagebreak
\subsection{Good and bad}
\label{tcp_conclusion}

There’s nothing too complicated about the project as such but a small practical thing to notice is that the order and type of method calls between the server and client can be confusing. It is vital that a writeUTF is picked up by a similar readUTF at the other side i.e, you can not readObject from a writeUTF. This took some time and error detection to get right.\\ 

The main lesson learned is about the protocol layers, each providing a specialized task. Each layer communicates with the layers above and below. 
Network layers send IP packets to (IP)addresses accross the network. The transport layer's UDP and TCP protocols sends IP packets to processes instead of addresses. TCP provides guarantees about reliability, ordering etc that UDP does not.


