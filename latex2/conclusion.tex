\chapter{Conclusion}
\minitoc
\section{TCP}

A protocol suite is a stack of layers. Each layer provides a service to the layer atop and extends the layer beneath. At the bottom is the physical layer (hardware) at the top the application layer. Protocols specify message sequence \& format\\

The IP protocol (network layer) is unreliable(packets get lost, arrive out of order).\\
The tcp protocol (transport layer) is reliable and ordered. \\

The Transmission Control Protocol (TCP),is a Transport layer protocol. TCP sends packets to another device on the same network or on a different network, reliably. It achieves reliability by resending the packet. The established connection (between the devices/processes) is closed only after the packet has been successfully delivered.\\

The TCP protocol belongs to the transport layer. There are two transport protocols in the TCP/IP suite; UDP and TCP. UDP transfers text messages and TCP transfers byte streams. Unlike UDP, TCP is reliable and ordered. It does so by giving every packet a number and then ordering the packets on arrival. TCP provides guarantees as to the delivery of the messages i.e, the message eventually arrive. It does so by using acknowledgements and retries (resend messages).   \\

  



\section{REST}
\section{Security}
Threats to distributed systems fall into three classes: leakage, tampering, vandalism.\\
 
methods of attack: eaves-dropping, masquerading, message tampering, Replaying, Denial of service.\\

Worst case assumptions: Exposed interfaces, insecure networks, Algorithms/code available to the enemy, Attackers have large resources. So, limit the trust base, limit the lifetime of a secret.\\

To counter threats we can apply a mechanism or a policy (or both)\\
	
A policy is to allow only some group/person access to my object(s)\\

A mechanism is to lock the door and give keys to a group/person.\\

Mechanisms includes Cryptography. There two types of keys: Private shared keys (session keys), and public private key pairs. Problem: How to share the keys? How to know that a message is not a replay?\\

Cryptography is used to maintain Authentication, Secrecy and integrity. \\

Sending messages in distributed systems poses a security risk. The enemy can intercept messages, man-in-the-middle attack, and the resend the message posing as the client, replays. To protect against those we use encryption and carefully designed protocols. \\

Instead of authenticating by password we use a challenge. A challenge is an encrypted message which can only be decrypted with the right key. Inside the encrypted message is a ticket, another challenge, encrypted in the server key. By adding the clients identity to the ticket a server can authenticate the sender of the message. By adding a sequence of nonces the server can authenticate subsequent messages from the client.\\

An enemy might intercept the initial message from the client to the authentication/token server but will be unable to decrypt the message, and ticket inside. The enemy might send this message to the server anyway but the server can verify the sender's identity by comparing the identity inside the ticket to the sender. \\


\section{Concurrency}
\section{Group Communication}
Remote invocations (RPC,RMI) imply a coupling between participants that is sometimes not wanted. Decoupling the system by introducing an intermediary introduces a couple of properties: Time and space uncoupling.\\

The most basic form of group communication, IP multicast provides some guarantees: Integrity (the message delivered is the same sent. No message is delivered twice.) Validity: Any message is eventually delivered. Agreement: If a message is delivered to one process it is delivered to all.\\

But IP mulitcast is not reliable and ordered. Packages may be lost and there's no guarantees as to the order of packages.\\

Lamport phrased the term \emph{happened-before} and provided the \emph{Lamport timestamp} in which each process increments its counter before sending a message. The receiver compares its own counter to that of the received message to determine the order. This is known as \emph{partial ordering}.\\

Vector clocks does one better providing total ordering by having each process keep a vector of timestamps for all processes, a sort of multi-process Lamport timestamp. This is known as total ordering. \\

Group communication as provided by IP multicast suffers from omission failures, messages may be lost. It also offers no ordering of messages. These properties can be provided by application layers like JGroups. JGroups is an overlay on the basic IP multicast offering, amongst other things, reliability and ordering in group communication. \\

JGroups delivers \emph{reliable} multicast i.e., where IP multicast is unreliable - it might drop messages, deliver messages multiple times or deliver messages out of order - JGroups offer a reliable multicast. JGroups offers atomicity; all members receive the message or none does. It offers ordering; the messages will be received by all receivers in the same order. And it offers lossless transmission by retransmission of messages.\\




\section{Mobile Client}