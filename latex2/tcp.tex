\chapter{TCP server and Serialization}
\minitoc


In this chapter we describe the result of the TCP lab exercise. in section \ref{tcp_lab} we describe the assignment. In section \ref{tcp_solution} we describe our solution. in section \ref{tcp_example} we provide an example run of the solution. In section \ref{tcp_reflection} we reflect on the theory behind the assignment. In section \ref{tcp_conclusion} we sum up what we've learned and round up the chapter.

\section{lab description}
\label{tcp_lab}
\textit{The purpose of this week’s lab exercise is to develop a simplified version of web server for task manager that runs on TCP protocol.}\\

\textit{In this lab exercise, you are required to develop the code for the following functionality.}\\

\textit{Develop java serialization classes for task-manager-xml using Java Architecture for XML Binding (JAXB) APIs (by annotating java classes) to handle deserialization/serialization from/to task-manager-xml in the server.}\\

\textit{Develop TaskManagerTCPServer and TaskManagerTCPClient classes to implement the above described functionality of server and client that communicate on the TCP protocol.}\\


\begin{comment}
[Optional] The server described above can only handle one single client at a time in each run. In order to make the server more robust and handle multiple clients concurrently, one may follow the approach suggested in the page. 173 of the course textbook [DS], to create a new connection for every client request that will run on a separate thread. Therefore, develop a TaskManagerTCPServer that can handle multiple concurrent clients.\\

[Optional] The functionality of TaskManagerTCPServer can be extended to offer more commands (e.g. OPTIONS, HEAD) similar to the HTTP protocol. In case of OPTIONS command, one may describe the list of commands offered by the server, where as for HEAD, one may only provide the number of tasks available for a given attendant instead of sending all the available tasks to the client.\\

\end{comment}


\section{Solution}
\label{tcp_solution}


\begin{comment}
Information in OO programs are typically stored as data structures whereas data in the messages used to communicate in distributed systems are binary. So, no matter the communication protocols used the data structures need to be flattened before transmitting and then reassembled at the other end. This is called marshalling and unmarshalling. The sender and transmitter must agree on the format used in order for the receiver to reassmble the data structures. CORBA, Java Object Serialization and XML are som of the formats used to transmit binary data from one node to another. \\

This can (as it often is) be done by middleware. In this project we have used JAXB to marshall our taskmanager data structure. JAXB use a XML format to transfer binary data. This works by annotating the data structures. Our taskmanager data structure in this case. JAXB can then marshall and unmarshall our data structure.\\
\end{comment}


We use the JAXB API to provide persistence. JAXB  unmarshall's the xml document into a 'taskmanager' object with a related collection of ‘Task’ objects and 'marshall's' it back into a xml document. \\ 


Our server opens a serversocket on a specified port and listens for clients. A client instantiates a socket specifying the server's address and port number. The client and server  communicates by passing byte streams through the port. The transmission of data is done with ObjectInputStream and ObjectOutputStream methods. \\

\subsubsection{Serialization}
Serialization and deserialization to and from xml is done with the JAXB API. To quote Oracle; \textit{JAXB provides methods for unmarshalling (reading) XML instance documents into Java content trees, and then marshalling (writing) Java content trees back into XML instance documents.} \\

JAXB uses annotations to achieve this. We annotate the Task and Taskmanager  Java objects and JAXB then knows how to convert these annotated objects into an xml tree-structure and back into an object graph.\\

\subsubsection{TCP}
The TCP server in our solution first connects to a serversocket and then waits for incoming requests on the port bound to the socket. Note this is a blocking call and the server won't perform any other tasks before a client connects. The Client creates a socket on the same port but this time with the servers InetAddress as a second argument. \\


Information in OO programs are typically stored as data structures whereas data in the messages used to communicate in distributed systems are binary. So, no matter the communication protocols used the data structures need to be flattened before transmitting and then reassembled at the other end. \\ 

\subsubsection{Byte Stream}
In Java, annotating data structures with the 'Serialization' keyword allows the ObjectInputStream and ObjectOutputStream classes to transform a graph of objects into an array of bytes for storage or transmission, and back into objects. \\

Our server and client communicates by passing messages in and out of the matching inputstreams and outputstreams. Command messages are passed via the writeUTF and received by the readUTF methods as  DataStreams. The Task and taskmanager objects are then sent as ObjectOutputStream and received as ObjectInputStream. \\



\subsection{http protocol}

The server responds to the client’s request by sending the request back. The client then proceeds accordingly. This mimics the HTTP protocol request-response pattern in detail?.

\section{example run}
\label{tcp_example}

In this example run we start out with an xml document containing one Task. Before the example run the xml document looks like this:

\begin{lstlisting}[caption=xml before run]
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<taskmanager>
	<tasks>
		
		<task id="handin-01" name="Submit assignment-01" date="16-12-2013"
			status="not-executed">
			<description>
				Work on mandatory assignment.
			</description>
			<attendants>student-01, student-02</attendants>
		</task>	
	</tasks>
</taskmanager>

\end{lstlisting}

During the run the client requests the POST method with new Task. After the run the xml document looks like this:

\begin{lstlisting}[caption=xml after POST]
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<taskmanager>
	<tasks>
		<task id="handin-01" name="Submit assignment-01" date="16-12-2013" status="not-executed">
			<description>
				Work on mandatory assignment.
			</description>
			<attendants>student-01, student-02</attendants>
		</task>
		<task id="one more cup of coffe" name="Tout les circles" date="15-09-2013" 
		status="mais jai le plus grande maillot du monde">
			<description>recondre</description>
			<attendants>bjarne, lise, hans, jimmy</attendants>
		</task>
	</tasks>
</taskmanager>
\end{lstlisting}

The client then requests the PUT method wanting to change the new 'one more cup of coffe' Task description from 'recondre' to 'recondre les roix'. Finally, the client requests the DELETE method with the taskid 'handin'01' parameter. After the run the xml document now looks like this:

\begin{lstlisting}[caption=xml after PUT]
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<taskmanager>
	<tasks>
		<task id="one more cup of coffe" name="Tout les circles" date="15-09-2013" status="mais jai le plus grande maillot du monde">
			<description>recondre les roix</description>
			<attendants>bjarne, lise, hans, jimmy</attendants>
		</task>
	</tasks>
</taskmanager>
\end{lstlisting}

\pagebreak

The TCP server code of interest looks like this.
% \lstinputlisting{TCPserver.java}

\begin{lstlisting}[caption= servers initial request-response]
while(running){
         System.out.println("\nServer: Waiting for client command");
         // client request
         String message = dis.readUTF(); // blocking call
         System.out.println("Server: client command received : " + message);
         // accept client request by returning the (request) message
         dos.writeUTF(message);    

\end{lstlisting}

\begin{lstlisting}[caption= server POST method]
if(message.equals("POST")){
    // receive Task object from client
   	Task t = (Task) ois.readObject();
   	
   	System.out.println("Server: object received '" + t.name +"', persisting object...");
   	// Add Task object to takmanager collection
   	serializer.allTasks.tasks.add(t);
   	// persist to xml document<
   	serializer.Serialize();
   	// acknowledge to client   	
   	dos.writeUTF("Task with id: '" +t.id + "' saved");
}

\end{lstlisting}


The corresponding TCP client code looks like this.
%\lstinputlisting{TCPclient.java}


\begin{lstlisting}
InetAddress serverAddress = InetAddress.getByName("localhost");            
// Open a socket for communication.
Socket socket = new Socket(serverAddress, 7896);
// Request message to server
String  message = "POST";			
System.out.println("Client: requesting " + message);

dos.writeUTF(message);		// send the request
response = dis.readUTF();	// blocking call          
System.out.println("Client: server response : " + response);         

Task t = new Task();
t.name = "Tout les circles";
t.id = "one more cup of coffe";
t.date = "15-09-2013";	
t.description = "recondre";
t.status = "mais jai le plus grande maillot du monde";
t.attendants = "bjarne, lise, hans, jimmy";

// if server acknowledges
if(response.equals(message)){
   	System.out.println("Client: server accepted. Sending object");
   	// send the Task object
   	ous.writeObject(t);
}else{
   	System.out.println("Client: the server did not acknowledge the object. Aborting.");
}

response = dis.readUTF();
System.out.println("Client: server response : " + response)
\end{lstlisting}



\section{Reflection}
\label{tcp_reflection}

In this exercise we worked with the TCP protocol. TCP is a transport layer level protocol. The TCP protocol provides communication between the application layer and the network layer?\\

The TCP protocol is part of the TCP/IP protocol suite. A protocol suite is a stack of protocols each responsible for a single logical task, e.g. transport, packaging etc. Each layer communicates with the layer directly above and below, only. Messages are passed down the stack at one side and they bubble up through the stack at the other side. \\

At the bottom of the TCP/IP suite are the physical layer (hardware). On top of the physical layer the network layer provides an interface to the transport layer, application services (and their protocols) are built on top of the transport layer based on TCP e.g. HTTP, SMTP, POP, FTP etc. More layers can be added to provide additional functionality e.g. security etc.\\

Using protocols gives us network independance i.e., different application types and languages can use the same network to communicate 
as long as they comply to the same protocol(s). Note \textit{even so, the heterogeneity of distributed systems makes it difficult to provide guarantees.}\\

In our example application we use the Transmission Control Protocol (or TCP protocol) to communicate with the network layer through a ‘socket’ connection. Our client sits at the application/presentation layer utilizing the TCP transport protocol to communicate with other nodes through the network layer.\\

Nodes communicate through a port. Both client and server addressed messages to the same port. The transport address (the IP number) was, in this case, composed of the computer's  ‘localhost’ address and a port number. \\

There are two transport protocols in the TCP/IP suite; UDP and TCP. UDP transfers text messages (IP packets) and TCP transfers byte streams (as IP packets). Furthermore, TCP is reliable and ordered i.e., TCP provides guarantees as to the ordering of its messages i.e., messages arrive in the order they were sent. And TCP provides guarantees as to the delivery of the messages be using a retry.  \\

In contrast, the underlying network protocol (the IP protocol ) offers only ‘best-effort’ semantics, there’s no guarantee of delivery and packets can be lost, duplicated, delayed or delivered out of order. Note \textit{This seem logical as the network layer (IP protocol) can not control the other end of the connection}. 

\pagebreak
\subsection{Good and bad}
\label{tcp_conclusion}

A source of concern is the structure of our code. This could only have been done better but since this was a course in Distributed Systems, and not in code writing norms, we chose to leave the code as is and concentrate on the distributed systems.  \\

The main lesson learned is about protocols and layers, each layer providing a specialized task. Each layer communicates with the layers above and below. Network layers send IP packets to (IP)addresses accross the network. The transport layer's UDP and TCP protocols sends IP packets to processes instead of addresses. TCP provides guarantees about reliability, ordering etc which UDP does not and this makes TCP well suited for server-client architectures in distributed systems. \\

A small practical thing to notice is that the order and type of method calls between the server and client can be confusing. It is vital that a writeUTF is picked up by a similar readUTF at the other side i.e, you can not readObject from a writeUTF method ;-) \\ 




